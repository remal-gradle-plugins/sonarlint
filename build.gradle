import static java.nio.charset.StandardCharsets.UTF_8

import java.nio.file.Files
import java.util.zip.ZipEntry
import java.util.zip.ZipInputStream
import java.util.zip.ZipOutputStream

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

buildscript {
    String rootGroupId = project.ext.rootGroupId = "name.remal.gradle-plugins.${rootProject.name}"
    String rootArtifactId = project.ext.rootArtifactId = rootProject.name
    String rootSnapshotVersion = project.ext.rootSnapshotVersion = '3-SNAPSHOT'
    dependencies {
        //classpath("$rootGroupId:$rootArtifactId:$rootSnapshotVersion") { version { strictly(rootSnapshotVersion) } }
        classpath 'name.remal.gradle-plugins.toolkit:build-logic:0.53.0'
    }
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

allprojects {
    group = project.rootGroupId
    version = project.rootSnapshotVersion
}

apply plugin: 'name.remal.toolkit.build-logic'

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

project.registerCrossCompileDependencyInfo(
    [
        name               : 'sonarlint',
        maxVersionNumbers  : 3,
        dependencyNotations: [
            'org.sonarsource.sonarlint.core:sonarlint-core',
        ],
    ]
)

allprojects {
    pluginManager.withPlugin('java') {
        dependencies {
            relocateClasses 'name.remal.gradle-plugins.toolkit:toolkit'
            relocateClasses 'com.google.guava:guava'

            optional 'name.remal.gradle-api:gradle-api'
        }
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

apply plugin: 'java-gradle-plugin'
apply plugin: 'name.remal.generate-sources'

dependencies {
    optional('org.sonarsource.sonarlint.core:sonarlint-core:8.12.0.58811') { transitive = false }
}

gradlePlugin {
    plugins {
        'name.remal.sonarlint' {
            id = 'name.remal.sonarlint'
            implementationClass = 'name.remal.gradle_plugins.sonarlint.SonarLintPlugin'
            displayName = 'SonarLint'
            description = property('repository-description')
        }
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

Provider<String> ltsNodeJsVersion = project.provider { project.getLtsNodeJsVersions()[0] }
project.nonJavaApiDependencies.add(project.provider { 'Node.js:lts:' + ltsNodeJsVersion.get() })

tasks.named('generateJava') {
    inputs.property('ltsNodeJsVersion', ltsNodeJsVersion)
    classFile(project.calculateBaseJavaPackage(), 'NodeJsVersions') {
        it.writePackage()
        it.println("")
        it.writeBlock("interface ${it.simpleName}") {
            it.println("String LATEST_NODEJS_LTS_VERSION = \"${it.escapeJava(ltsNodeJsVersion.get())}\";")
        }
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

Configuration sonarArtifactsToDownloadForBuildCacheConf = project.configurations.create('sonarArtifactsToDownloadForBuildCache')

Closure<Configuration> createSonarArtifactsConfiguration = { String name, boolean addToIndirectApi = true ->
    return project.configurations.create(name) { Configuration conf ->
        conf.transitive = false
        conf.extendsFrom = []
        conf.dependencies.all { Dependency dep ->
            sonarArtifactsToDownloadForBuildCacheConf.dependencies.add(dep.copy())
            if (dep instanceof ModuleDependency) {
                dep.transitive = false
            }
            if (dep instanceof ExternalDependency) {
                dep.version { strictly(dep.version) }
            }
        }

        if (addToIndirectApi) {
            project.configurations.indirectApi.extendsFrom(conf)
        }
    }
}

createSonarArtifactsConfiguration('sonarCoreArtifacts')
createSonarArtifactsConfiguration('sonarPluginArtifacts')

dependencies {
    // Core:
    sonarCoreArtifacts 'org.sonarsource.sonarlint.core:sonarlint-core:8.12.0.58811'


    // Plugins:
    sonarPluginArtifacts 'org.sonarsource.java:sonar-java-plugin:7.16.0.30901'
    sonarPluginArtifacts 'org.sonarsource.kotlin:sonar-kotlin-plugin:2.12.0.1956'
    sonarPluginArtifacts 'org.sonarsource.slang:sonar-ruby-plugin:1.11.0.3905'
    sonarPluginArtifacts 'org.sonarsource.slang:sonar-scala-plugin:1.11.0.3905'
    sonarPluginArtifacts 'org.sonarsource.xml:sonar-xml-plugin:2.6.1.3686'
    sonarPluginArtifacts 'org.sonarsource.javascript:sonar-javascript-plugin:9.12.1.20358'

    // Plugins for languages that highly unlikely are built with Gradle:
    //sonarPluginArtifacts 'org.sonarsource.php:sonar-php-plugin:3.25.0.9077'
    //sonarPluginArtifacts 'org.sonarsource.python:sonar-python-plugin:3.17.0.10029'
    //sonarPluginArtifacts 'org.sonarsource.sonarlint.omnisharp:sonarlint-omnisharp-plugin:1.4.0.50839'

    // Broken plugins:
    //sonarPluginArtifacts 'org.sonarsource.html:sonar-html-plugin:3.6.0.3106' // `org.jboss.el:jboss-el:1.0_02.CR4` dependency can't be found in Maven Central

    // Known SonarQube plugins without SonarLint support:
    //sonarPluginArtifacts 'org.sonarsource.css:sonar-css-plugin:1.4.2.2002'
    //sonarPluginArtifacts 'org.sonarsource.dotnet:sonar-csharp-plugin:8.45.0.54064'
    //sonarPluginArtifacts 'org.sonarsource.dotnet:sonar-vbnet-plugin:8.45.0.54064'
    //sonarPluginArtifacts 'org.sonarsource.flex:sonar-flex-plugin:2.7.0.2865'
    //sonarPluginArtifacts 'org.sonarsource.groovy:sonar-groovy-plugin:1.4'
    //sonarPluginArtifacts 'org.sonarsource.iac:sonar-iac-plugin:1.9.2.2279'
    //sonarPluginArtifacts 'org.sonarsource.slang:sonar-go-plugin:1.10.0.3710'
    //sonarPluginArtifacts 'org.sonarsource.text:sonar-text-plugin:1.1.0.282'
    //sonarPluginArtifacts 'org.sonarsource.typescript:sonar-typescript-plugin:2.1.0.4359'
    //sonarPluginArtifacts 'com.github.sbaudoin:sonar-shellcheck-plugin:2.5.0'
    //sonarPluginArtifacts 'com.github.sbaudoin:sonar-yaml-plugin:1.7.0' // broken (depends on Logback)
    //sonarPluginArtifacts 'com.github.sbaudoin:sonar-ansible-plugin:2.5.1'
}

tasks.named('generateJava') { Task task ->
    inputs.files(configurations.sonarCoreArtifacts).withPropertyName('sonarCoreArtifacts').optional()
    inputs.files(configurations.sonarPluginArtifacts).withPropertyName('sonarPluginArtifacts').optional()
    classFile(project.calculateBaseJavaPackage(), 'SonarDependencyType') {
        it.writePackage()
        it.println("")
        it.writeBlock("enum ${it.simpleName}") {
            it.println("CORE,")
            it.println("PLUGIN,")
            it.println(";")
        }
    }
    classFile(project.calculateBaseJavaPackage(), 'SonarDependency') {
        it.writePackage()
        it.println("")
        it.writeImport("lombok.Builder")
        it.writeImport("lombok.Value")
        it.println("")
        it.println("@Value")
        it.println("@Builder")
        it.writeBlock("class ${it.simpleName}") {
            it.println("SonarDependencyType type;")
            it.println("String group;")
            it.println("String name;")
            it.println("String version;")
        }
    }
    classFile(project.calculateBaseJavaPackage(), 'SonarDependencies') {
        it.writePackage()
        it.println("")
        it.writeStaticImport("lombok.AccessLevel", "PRIVATE")
        it.println("")
        it.writeImport("com.google.common.collect.ImmutableMap")
        it.writeImport("java.util.Map")
        it.writeImport("lombok.NoArgsConstructor")
        it.writeImport("lombok.val")
        it.println("")
        it.println("@NoArgsConstructor(access = PRIVATE)")
        it.writeBlock("abstract class ${it.simpleName}") {
            it.println("")
            it.println("private static final Map<String, SonarDependency> MAPPING = ImmutableMap.<String, SonarDependency>builder()")
            configurations.sonarCoreArtifacts.dependencies.forEach { Dependency dep ->
                it.println("    .put(\"${it.escapeJava(dep.name)}\", SonarDependency.builder()")
                it.println("        .type(SonarDependencyType.CORE)")
                it.println("        .group(\"${it.escapeJava(dep.group)}\")")
                it.println("        .name(\"${it.escapeJava(dep.name)}\")")
                it.println("        .version(\"${it.escapeJava(dep.version)}\")")
                it.println("        .build()")
                it.println("    )")
            }
            configurations.sonarPluginArtifacts.dependencies.forEach { Dependency dep ->
                it.println("    .put(\"${it.escapeJava(dep.name)}\", SonarDependency.builder()")
                it.println("        .type(SonarDependencyType.PLUGIN)")
                it.println("        .group(\"${it.escapeJava(dep.group)}\")")
                it.println("        .name(\"${it.escapeJava(dep.name)}\")")
                it.println("        .version(\"${it.escapeJava(dep.version)}\")")
                it.println("        .build()")
                it.println("    )")
            }
            it.println("    .build();")

            it.println("")
            it.writeBlock("public static Map<String, SonarDependency> getSonarDependencies()") {
                it.println("return MAPPING;")
            }

            it.println("")
            it.writeBlock("public static SonarDependency getSonarDependency(String id)") {
                it.println("val dependency = getSonarDependencies().get(id);")
                it.writeBlock("if (dependency == null)") {
                    it.println("throw new IllegalStateException(\"Sonar dependency is not registered: \" + id);")
                }
                it.println("return dependency;")
            }
        }
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

tasks.named('processReadme') {
    readmeFileProcessors.add(
        { File readmeFile ->
            String content = readmeFile.getText('UTF-8')

            content = content.replaceAll(
                /<!--\s*(sonar-plugins-list)\s*-->[\s\S]*?<!--\s*\/\s*\1\s*-->/
            ) {
                String tag = it[1]
                logger.lifecycle('  Handling {}', tag)
                StringBuilder listContent = new StringBuilder()
                listContent.append('\n')

                configurations.sonarPluginArtifacts.dependencies.forEach { Dependency dep ->
                    if ((dep.group + '.').startsWith('org.sonarsource.')
                        && dep.name.startsWith('sonar-') && dep.name.endsWith('-plugin')
                    ) {
                        String lang = dep.name.substring('sonar-'.length(), dep.name.length() - '-plugin'.length())
                        if (!lang.isEmpty()) {
                            listContent.append("* [`${lang}`](https://rules.sonarsource.com/${lang})\n")
                            return
                        }
                    }

                    listContent.append("* [`${dep.group}:${dep.name}:${dep.version}`](https://mvnrepository.com/artifact/${dep.group}/{$dep.name}/${dep.version})\n")
                }

                return "<!--$tag-->\n$listContent\n<!--/$tag-->"
            }

            readmeFile.setText(content, 'UTF-8')
        }
    )
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

allprojects {
    /*
    if (gradle.startParameter.taskNames.isEmpty()
        || gradle.startParameter.taskNames == ['processIdeaSettings']
        || gradle.startParameter.taskNames == ['dependencies']
        || gradle.startParameter.taskNames == ['help']
    ) {
        return
    }
    */

    def artifactType = Attribute.of('artifactType', String)
    def unshadedSonar = Attribute.of('unshaded', Boolean)
    dependencies {
        attributesSchema {
            attribute(unshadedSonar)
        }
        artifactTypes.getByName('jar') {
            attributes.attribute(unshadedSonar, false)
        }
    }

    configurations
        .matching { !it.name.startsWith('sonar') }
        .all { Configuration conf ->
            if (conf.state != Configuration.State.UNRESOLVED) return

            conf.dependencies.withType(ExternalModuleDependency).configureEach { ExternalModuleDependency dep ->
                if ("${dep.group}:${dep.name}" == 'org.sonarsource.sonarlint.core:sonarlint-core') {
                    dep.attributes {
                        attribute(unshadedSonar, true)
                    }
                }
            }
        }

    dependencies {
        registerTransform(UnshadeSonar) {
            from.attribute(unshadedSonar, false).attribute(artifactType, 'jar')
            to.attribute(unshadedSonar, true).attribute(artifactType, 'jar')
        }
    }
}

abstract class UnshadeSonar implements TransformAction<UnshadeParameters> {

    interface UnshadeParameters extends TransformParameters {}

    @InputArtifact
    abstract Provider<FileSystemLocation> getInputArtifact()

    @Override
    void transform(TransformOutputs outputs) {
        File file = inputArtifact.get().asFile
        File outputFile = outputs.file(file.name)
        if (outputFile.exists() && outputFile.lastModified() >= rootProject.buildFile.lastModified()) return

        Files.createDirectories(outputFile.parentFile.toPath())
        new ZipInputStream(new FileInputStream(file), UTF_8).withCloseable { ZipInputStream inputStream ->
            new ZipOutputStream(new FileOutputStream(outputFile), UTF_8).withCloseable { ZipOutputStream outputStream ->
                while (true) {
                    ZipEntry zipEntry = inputStream.nextEntry
                    if (zipEntry == null) break

                    if (zipEntry.name.contains('/shaded/')) continue

                    if (!zipEntry.name.contains('sonar') && !zipEntry.name.startsWith('META-INF/')) continue

                    outputStream.putNextEntry(zipEntry)
                    outputStream << inputStream
                }
            }
        }
    }

}
